---
title: 油猴用户脚本开发心得
date: 2020-04-21 08:49:00
tags: [JavaScript, Userscript, Tampermonkey]
---

## 文档参考

+ [MDN Web Docs](https://developer.mozilla.org/zh-CN/)
+ [Tampermonkey Doc](https://www.tampermonkey.net/documentation.php)
+ [Greasemonkey_Manual:API](https://wiki.greasespot.net/Greasemonkey_Manual:API)

## 注意

+ 以下内容均为在特定时间特定环境的个人经验之谈，可能会在以后或不同环境中不适用。

## Greasemonkey/Tampermonkey API相关

+ 自某个版本开始有了 `GM.*` 形式的API，可以用于取代旧版本的 `GM_*` 形式的API。
  + `GM.*` 的API函数全都是异步函数，而 `GM_*` 的API函数是同步的。

### [unsafeWindow](https://wiki.greasespot.net/UnsafeWindow)

+ 在声明了 `@grant unsafeWindow` 之后，脚本上下文中的 `window` 会被替换成一个由插件提供的"沙箱window"。
+ 在沙箱环境下，`Worker` 以及一些API可能会无法工作。
+ 可以使用 `window = unsafeWindow;` 的方式脱离沙箱环境，但要保证这行在需要脱离沙箱的代码之前。另外也可以保留一个原来的 `window` 的引用以备用。

## ECMAScript 相关

+ [W3C Workers](https://w3c.github.io/workers/)

### [Worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker) 和 [DedicatedWorkerGlobalScope](https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope)

+ `Worker` 可以通过如下方法来实现*从代码直接加载*而不用URL以实现跨域加载 `Worker`
  
  ```javascript
  const content = 'Worker中要执行的代码';
  const url = URL.createObjectURL(new Blob([content], { type: 'text/javascript' }));
  const worker = new Worker(url);
  // ...
  ```

+ 参考[Web workers without a separate Javascript file?](https://stackoverflow.com/questions/5408406/web-workers-without-a-separate-javascript-file)

+ 还有一种可行的从跨域URL加载的方式，简单说就是在上述方法中使用 `importScripts` 加载启用CORS的域的代码

```javascript
const URL = 'xxxxxx';
const content = `importScripts(${URL});`;
const worker = new Worker(URL.createObjectURL(new Blob([content], { type: 'text/javascript' })));
```

+ 参考[Cross Domain Web Worker?](https://stackoverflow.com/questions/20410119/cross-domain-web-worker)
+ 另一种可能的方式[Execute web worker from different origin](https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin)

### [SharedWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorker) 和 [SharedWorkerGlobalScope](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorkerGlobalScope)

+ `SharedWorker` 在通过上述方式使用时没有效果(但这种方法不会提示错误，是否真的不可用还有待研究)，由于同源策略也无法执行你自己的脚本。目前还没有找到一个合理有效的方法在用户脚本中使用 `SharedWorker`
+ 参考[How can I load a shared web worker with a user-script?](https://stackoverflow.com/questions/38810002/how-can-i-load-a-shared-web-worker-with-a-user-script)
+ 注：上述页面中的部分答案可能有用，但这不应该是 `SharedWorker` 本身应用的场景

### [ServiceWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker) 和 [ServiceWorkerGlobalScope](https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerGlobalScope)

+ `ServiceWorker` 同 `SharedWorker` 没有合理有效的方法在用户脚本中使用，但使用上述方法时均直接提示错误，因此目前这些方法对 `ServiceWorker` 均不可用

## 模块化

### 从URL中加载的方式 [import](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import) / [export](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)

+ 从某个版本开始，各大浏览器实现了动态`import`，因此可以通过这种方式在用户脚本中从URL加载*模块(Module)*
+ 示例
  
  ```javascript
  // 模块中的代码
  export function f () { console.log('here is function f'); }
  export const k = 1;
  export default function func () { console.log('here is function func'); }

  // 用户脚本或其他地方的代码，注意动态import的使用方式和静态import的使用方式有所不同
  const mod = await import(URL);
  console.log(mod.f, mod.f());
  console.log(mod.k);
  console.log(mod.default); // 注意这里，default指代的是用export default导出的东西
  ```

+ 在 `Web Worker` 中暂时无法使用`import`，参考[Web Workers - How To Import Modules](https://stackoverflow.com/questions/44118600/web-workers-how-to-import-modules)
  + *Chrome 80* 修复了这个bug

### 直接执行代码的方式 [eval](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval) / [Function](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function) / [AsyncFunction](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)

+ 如果想要异步加载，需要保证加载过程的代码中的每个异步函数都有正确地`await`，否则可能导致加载顺序不一致
+ 关于`eval`和`Function`性能问题：在 *Chrome* 中测试得到 `eval`有最高的效率；在 *Firefox* 中测试得到 `Function` 更快。此外，在 *Chrome* 中的执行速度比 *Firefox* 整体快了数倍

## 跨域相关

### [CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

+ 在用户脚本中跨域获取HTTP请求*自己的文件*可以通过脚本的`@resource`实现，或把文件挂在代码托管的网站上，因为这些网站通常是默认开启CORS的
+ 如果需要请求*他人的文件*(如调用API等)可以使用[GM.xmlHttpRequest](https://wiki.greasespot.net/GM.xmlHttpRequest)
+ CORS对`Worker`/`SharedWorker`/`ServiceWorker`都不能产生效果，因此你不能通过如下方式从跨域URL加载
  
  ```javascript
  var blockedWorker = new Worker("https://not-example.com/");
  blockedWorker = new SharedWorker("https://not-example.com/");
  navigator.serviceWorker.register('https://not-example.com/sw.js');
  ```

+ 参考[Why can I fetch this Cross origin file but I can't create a Worker from it?](https://stackoverflow.com/questions/60766732/why-can-i-fetch-this-cross-origin-file-but-i-cant-create-a-worker-from-it)
+ `importScripts`受CORS控制，因此可以用这个方式解决上述的问题，见上文

### [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)

+ 如果网站启用CSP并且作出限制，用户脚本基本上没法做被限制的操作，不过我目前没有遇到
